<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python 爬虫(一)]]></title>
    <url>%2F2018%2F02%2F24%2Fcrawl-1%2F</url>
    <content type="text"><![CDATA[Python爬虫导言爬虫一般是使用者通过某种途径爬取目标站点所需要的数据。这种途径包括站点本身的sitemap、网站提供的API、当然也包括自己编写的小蜘蛛。 爬取前有必要了解的一些东西robots.txt这是一个文件，里面给出了爬虫爬取该网站时应该遵守的一些规定，来约束爬虫的行为，当然在后面自然有办法违背robots.txt文件，但同时也要承担爬虫被封甚至ip封禁的风险。robots.txt参考文件 sitemapsitemap文件里面包含网站最新的内容，通过这个东西可以爬取我们需要的内容而不需要访问每一个网页。但是它也存在内容缺少不完整等问题（例如本博客的sitemap就傻了（捂脸））取网站地图标准的定义 builtwith模块1builtwith.parse('url') 通过这个模板可以分析这个网站构建所使用的部分类型，从而可以确定爬取的大致方向 WHOIS通过whois协议可以查找出域名注册者是谁。1whois.whois('域名') 搜索引擎谷歌百度估计都不陌生，讲道理搜索引擎我们真的用对方向了？谈谈搜索黑魔法比如说，爬取前你想估算目标站点究竟有多大，来决定究竟使用多线程任务还是单线程串行爬、使用框架还是原生态等等。善于利用搜索引擎的就会site:url 然后谷歌百度就会在左上角About xxx results（xxx second），并且这个量一般只会多不会少。 谷歌其他高级搜索参数用法 百度高级搜索参数可视化搜索 搜索常用的关键词： example #用例 tutorial #教程 doc #文档 awesome #集合 github #最大开源平台 stackoverflow #码农版知乎 比如说，你想看看python有什么很棒的开源项目，可以选择这样搜索，python awesome github，当然也可以直接到github上面搜。]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>&lt;font size=6&gt;爬虫&lt;/font&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8新特性（三）]]></title>
    <url>%2F2017%2F11%2F07%2FJ8-2%2F</url>
    <content type="text"><![CDATA[前几天看到一条较为劲爆的信息:Kotlin/Native支持IOS和Web开发。emmm，Kotlin要一统天下？还是先喝口水冷静一下吧。 Java 8新特性（三)这章主要谈J8的Stream（流式操作）。 Stream是什么？J8中，stream操作主要是对collection集合数据的操作。它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。（官方的翻译总是文绉绉的，看起来头大）反正就是类似一个类的数据，你需要特定属性对象进行某项属性的处理（升降序、最大最小、平均之类的），通过处理后（所谓的“聚合操作”），再在处理后的数据里面取出类的某些属性进另外一个集合里面。在J7，大家应该比较普遍的就是使用Iterator（迭代器）来遍历集合，处理数据，然后在取属性，可能用这种方法代码量15行，但是stream可能只是1-5行，而且stream并行的流可以很大程度上提高程序的执行效率 流的使用详解Stream 的使用就是获得一个stream对象,实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。在Java 8 中，集合的接口有两个方法来产生流： stream()：该方法返回一个将集合视为源的连续流。 parallelStream()：该方法返回一个将集合视为源的并行流。 流的构造与转换构造流的几种常见方法1234561.Stream stream = Stream.of("a", "b", "c");2.String [] strArray = new String[] &#123;"a", "b", "c"&#125;; stream = Stream.of(strArray); stream = Arrays.stream(strArray);3.List&lt;String&gt; list = Arrays.asList(strArray); stream = list.stream(); 数值流的构造123IntStream.of(new int[]&#123;1, 2, 3&#125;).forEach(System.out::println);IntStream.range(1, 3).forEach(System.out::println);IntStream.rangeClosed(1, 3).forEach(System.out::println); 流转换为其它数据结构123456789// 1. ArrayString[] strArray1 = stream.toArray(String[]::new);// 2. CollectionList&lt;String&gt; list1 = stream.collect(Collectors.toList());List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));Set set1 = stream.collect(Collectors.toSet());Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));// 3. StringString str = stream.collect(Collectors.joining()).toString(); 流的操作 Intermediate(中间操作): map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered filter()：对元素进行过滤；sorted()：对元素排序；map()：元素的映射；distinct()：去除重复元素；subStream()：获取子 Stream 等。 Terminal(终止操作)：forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator forEach()：对每个元素做处理；toArray()：把元素导出到数组；findFirst()：返回第一个匹配的元素；anyMatch()：是否有匹配的元素等。 Short-circuiting：anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit 下面来看看流操作的具体Demo map/flatMap:该方法用于将每个元素映射到对应的结果上 collector:合并Stream的元素处理结果。它可以用于返回一个字符串列表 Demo1:转换大写123List&lt;String&gt; output = wordList.stream().map(String::toUpperCase).collect(Collectors.toList()); Demo2:平方数1234List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4);List&lt;Integer&gt; squareNums = nums.stream().map(n -&gt; n * n).collect(Collectors.toList()); Demo3:一对多1234567Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of( Arrays.asList(1), Arrays.asList(2, 3), Arrays.asList(4, 5, 6) );Stream&lt;Integer&gt; outputStream = inputStream.flatMap((childList) -&gt; childList.stream()); filter: 该方法用于过滤满足条件的元素。 Demo4:留下偶数123Integer[] sixNums = &#123;1, 2, 3, 4, 5, 6&#125;;Integer[] evens =Stream.of(sixNums).filter(n -&gt; n%2 == 0).toArray(Integer[]::new); foreach: 该方法用于对Stream中的每个元素进行迭代操作Demo5：迭代输出123roster.stream() .filter(p -&gt; p.getGender() == Person.Sex.MALE) .forEach(p -&gt; System.out.println(p.getName())); 注意：forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算，相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。同时，forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。 Demo6：peek 对每个元素执行操作并返回一个新的 Stream123456Stream.of("one", "two", "three", "four") .filter(e -&gt; e.length() &gt; 3) .peek(e -&gt; System.out.println("Filtered value: " + e)) .map(String::toUpperCase) .peek(e -&gt; System.out.println("Mapped value: " + e)) .collect(Collectors.toList()); limit: 该方法用于减少Stream的大小。Demo7:有限制地输出10个随机数。 12Random random = new Random();random.ints().limit(10).forEach(System.out::println); sorted: 以有序的形式输出10个随机数 12Random random = new Random();random.ints().limit(10).sorted().forEach(System.out::println); min/max/distinct: 该方法用于最小、最大、不重复的值。Demo8:找出最长一行的长度 1234567BufferedReader br = new BufferedReader(new FileReader("c:\\SUService.log"));int longest = br.lines(). mapToInt(String::length). max(). getAsInt();br.close();System.out.println(longest); Demo9:找出全文的单词，转小写，并排序123456789List&lt;String&gt; words = br.lines(). flatMap(line -&gt; Stream.of(line.split(" "))). filter(word -&gt; word.length() &gt; 0). map(String::toLowerCase). distinct(). sorted(). collect(Collectors.toList());br.close();System.out.println(words); match:allMatch：Stream 中全部元素符合传入的 predicate，返回 trueanyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 truenoneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true Demo10：使用match123456789101112List&lt;Person&gt; persons = new ArrayList();persons.add(new Person(1, "name" + 1, 10));persons.add(new Person(2, "name" + 2, 21));persons.add(new Person(3, "name" + 3, 34));persons.add(new Person(4, "name" + 4, 6));persons.add(new Person(5, "name" + 5, 55));boolean isAllAdult = persons.stream(). allMatch(p -&gt; p.getAge() &gt; 18);System.out.println("All are adult? " + isAllAdult);boolean isThereAnyChild = persons.stream(). anyMatch(p -&gt; p.getAge() &lt; 12);System.out.println("Any child? " + isThereAnyChild); reduce: 这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。 Demo11:reduce使用123456789101112// 字符串连接，concat = "ABCD"String concat = Stream.of("A", "B", "C", "D").reduce("", String::concat); // 求最小值，minValue = -3.0double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); // 求和，sumValue = 10, 有起始值int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);// 求和，sumValue = 10, 无起始值sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();// 过滤，字符串连接，concat = "ace"concat = Stream.of("a", "B", "c", "D", "e", "F"). filter(x -&gt; x.compareTo("Z") &gt; 0). reduce("", String::concat); Stream.iterate: iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。 Demo12:等差数列1Stream.iterate(0, n -&gt; n + 3).limit(10). forEach(x -&gt; System.out.print(x + " "));. IntSummaryStatistics :统计工具 Demo12:计算Stream处理完成后的所有统计数据12345678List&lt;Integer&gt; numbers = Arrays.asList(2, 3, 3, 2, 5, 2, 7);IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();System.out.println("Highest number in List : " + stats.getMax());System.out.println("Lowest number in List : " + stats.getMin());System.out.println("Sum of all numbers : " + stats.getSum());System.out.println("Average of all numbers : " + stats.getAverage()); 总结虽然下面的blog讲解的Streams API已经好多了，本文大部分也是参考了下面来进行编辑的，感觉好多API没有使用过，还是建议自己去官网上面学习。Java 8 中的 Streams API 详解]]></content>
      <categories>
        <category>Java 8</category>
      </categories>
      <tags>
        <tag>&lt;font size=6&gt;Java 8&lt;/font&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8新特性（二）]]></title>
    <url>%2F2017%2F11%2F03%2FJ8-1%2F</url>
    <content type="text"><![CDATA[农训之后便是一顿实验课、实验课、实验课……小编的内心是崩溃的……但是该更博文还是得更博文滴… Java 8新特性(二)本章继续介绍J8特性，包括函数式接口，Optional类，默认方法三部分 函数式接口Java 8有个概念–函数式接口（Functional Interfaces）。接口里面只有一个抽象方法，这个方法能直接在接口中运行，那这个接口称之为函数式编程。在函数式接口前面一般添加注解@FunctionalInterface，JVM会自动判断。 一般接口里面只有一个方法，并且前面有注解@FunctionalInterface，位于java.util.Funtion包中，一般就可以判断这是一个函数式接口了 下面列出几个常用的函数式接口： 接口 描述 Predicate Represents a predicate (boolean-valued function) of one argument. Consumer Represents an operation that accepts a single input argument and returns no result. Unlike most other functional interfaces, Consumer is expected to operate via side-effects. Supplier Represents a supplier of results.There is no requirement that a new or distinct result be returned each time the supplier is invoked. Function Represents a function that accepts one argument and produces a result. emmm…小编开始看的时候也有点懵逼，那就一个一个解决，看他们API然后再看他们的Demo SupplierMethod Summary Modifier and Type Method and Description T get() Gets a result. Demo：123456789101112131415161718192021public interface Supplier&lt;T&gt; &#123; /** * Gets a result. * * @return a result */ T get();&#125;static class PersonFactory &#123; private Supplier&lt;Person&gt; supplier; public PersonFactory(Supplier&lt;Person&gt; supplier) &#123; this.supplier = supplier; &#125; public Person getPerson() &#123; return supplier.get(); &#125; &#125; 通过Demo，结合description，在加上他的method，不难理解，supplier就是返回T对象的函数式接口。 Function常用Method Summary Modifier and Type Method and Description R apply(T t) Applies this function to the given argument. Demo：12345678910111213141516public class FunctionTest &#123; static void modifyTheValue(int valueToBeOperated, Function&lt;Integer, Integer&gt; function)&#123; int newValue = function.apply(valueToBeOperated); System.out.println(newValue); &#125; public static void main(String[] args) &#123; int incr = 20; int myNumber = 10; modifyTheValue(myNumber, val-&gt; val + incr); myNumber = 15; modifyTheValue(myNumber, val-&gt; val * 10); Function&lt;Integer,Integer&gt; test3 = num -&gt; num -100; Function&lt;Integer,Integer&gt; test4 = num-&gt; "somestring".length() + num - 100; modifyTheValue(myNumber, test3); modifyTheValue(myNumber, test4); &#125;&#125; 结果为：30 150 -85 -75 不难理解，function表示接受一个参数并产生结果的函数。它的适用场景应该是他们传入同一类型的参数，但是执行不同的方法可以使用这种函数式接口。类似，一个类的printxxxx方法，可能根据传入一个相同的类对象，但是希望他print出不同的内容，可能是姓名、年龄、e-mail等等。 ConsumerMethod Summary Modifier and Type Method and Description void accept(T t) Performs this operation on the given argument. default Consumer andThen(Consumer&lt;? super T&gt; after) Returns a composed Consumer that performs, in sequence, this operation followed by the after operation. Consumer接口和function接口非常相似,小编就修改function接口的Demo作为Consumer的Demo，方便对比理解:1234567891011121314public class ConsumerTest &#123; static void modifyTheValue(int valueToBeOperated, Consumer&lt;Integer&gt; function)&#123; function.accept(valueToBeOperated); &#125; public static void main(String[] args) &#123; int incr = 20; int myNumber = 10; modifyTheValue(myNumber, val-&gt; System.out.println(val + incr)); myNumber = 15; modifyTheValue(myNumber,val-&gt; System.out.println(val * 10)); Consumer&lt;Integer&gt; test3 = num -&gt; System.out.println(num -100); Consumer&lt;Integer&gt; test4 = num-&gt; System.out.println("somestring".length() + num - 100); modifyTheValue(myNumber, test3); modifyTheValue(myNumber, test4); &#125;&#125; 结果依然是： 30 150 -85 -75 观察接口，对比，然后不难得出结论：Consumer表示接受单个输入参数并且不返回结果的操作。而Function是有结果的，执行完接口的方法后，将新结果返回给newValue，然后print。 Predicate常用Method Summary Modifier and Type Method and Description boolean test(T t) Evaluates this predicate on the given argument. static Predicate isEqual(Object targetRef) Returns a predicate that tests if two arguments are equal according to Objects.equals(Object, Object). Demo：123456789101112131415public class PredicateTest&#123; public static void main(String[] args) throws InterruptedException &#123; String name = ""; String name1 = "123"; String name2 = "123456"; System.out.println(judgeInput(name,input -&gt; !input.isEmpty() &amp;&amp; input.length() &lt;= 3 )); System.out.println(judgeInput(name1,input -&gt; !input.isEmpty() &amp;&amp; input.length() &lt;= 3 )); System.out.println(judgeInput(name2,input -&gt; !input.isEmpty() &amp;&amp; input.length() &lt;= 3 )); &#125; public static boolean judgeInput(String name,Predicate&lt;String&gt; function) &#123; return function.test(name); &#125;&#125; 结果为：false true false 不难理解，Predicate是一个布尔值函数。Predicate接口里面还有好几个常用的函数，好像test是抽象的，有好一些函数是默认方法的，在J8之前的版本中，小编记得，好像接口里面只能定义函数而不能实现函数，但是在J8，接口可以包含带有实现代码的方法，这些方法称为default方法，本节也会谈及默认方法的一些使用，但是！！！如今快到12点了，小编要睡晚觉了，明天继续写….晚安 接口增强J8对接口做了一些改变，在书本上面是这样说的，抽象类不可以用于new创建抽象类对象。抽象类可以包含抽象方法，抽象方法只有定义而没有实现，由子类实现，还要注意到，抽象方法是非静态的。一个包含抽象方法的类必须声明为抽象类。而接口只含常量和抽象方法，但是在J8中，允许我们给接口添加一个非抽象的方法实现，只需要使用 default 关键字即可，这个特征又叫做扩展方法。 默认方法Demo:1234567891011public interface DefaultFunInterface &#123;default int count()&#123;return 1;&#125;&#125;public class SubDefaultFunClass implements DefaultFunInterface &#123;public static void main(String[] args)&#123; SubDefaultFunClass sub = new SubDefaultFunClass();sub.count();&#125;&#125; 静态方法Demo:J8中，还允许在接口中定义静态的方法，无需创建实例直接调用即可。1234567891011public interface StaticFunInterface &#123;public static int find(int count)&#123;return 1+count;&#125;&#125;public class TestStaticFun &#123;public static void main(String[] args)&#123;int count = 1;StaticFunInterface.fine(count);&#125;&#125; Optional先来看看，官方的是怎么对这个API描述的：A container object which may or may not contain a non-null value. If a value is present, isPresent() will return true and get() will return the value.Additional methods that depend on the presence or absence of a contained value are provided, such as orElse() (return a default value if value not present) and ifPresent() (execute a block of code if the value is present). This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of Optional may have unpredictable results and should be avoided. 大概就是说，Optional是一个容器对象，可以容纳null or not null的值，网上某些资料说它容纳not null对象其实是片面的，准确来说，应该是是Optional专注于处理可用或者不可用的值，而不是检查那些空值（null）。 部分Method Summary： Modifier and Type Method and Description static Optional of(T value) Returns an Optional with the specified present non-null value. static Optional ofNullable(T value) Returns an Optional describing the specified value, if non-null, otherwise returns an empty Optional. T orElse(T other) Return the value if present, otherwise return other. T orElseGet(Supplier&lt;? extends T&gt; other) Return the value if present, otherwise invoke other and return the result of that invocation. T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) Return the contained value, if present, otherwise throw an exception to be created by the provided supplier. T get() If a value is present in this Optional, returns the value, otherwise throws NoSuchElementException. boolean isPresent() Return true if there is a value present, otherwise false. 太多方法了，大家可以等一下到下面链接到官网里面寻找，直接上Demo：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class OptionalDemo &#123; public static void main(String[] args) &#123; //创建Optional实例，也可以通过方法返回值得到。 Optional&lt;String&gt; name = Optional.of("Sanaulla"); //创建没有值的Optional实例，例如值为'null' Optional empty = Optional.ofNullable(null); //isPresent方法用来检查Optional实例是否有值。 if (name.isPresent()) &#123; //调用get()返回Optional值。 System.out.println(name.get()); &#125; try &#123; //在Optional实例上调用get()抛出NoSuchElementException。 System.out.println(empty.get()); &#125; catch (NoSuchElementException ex) &#123; System.out.println(ex.getMessage()); &#125; //ifPresent方法接受lambda表达式参数。 //如果Optional值不为空，lambda表达式会处理并在其上执行操作。 name.ifPresent((value) -&gt; &#123; System.out.println("The length of the value is: " + value.length()); &#125;); //如果有值orElse方法会返回Optional实例，否则返回传入的错误信息。 System.out.println(empty.orElse("There is no value present!")); System.out.println(name.orElse("There is some value!")); //orElseGet与orElse类似，区别在于传入的默认值。 //orElseGet接受lambda表达式生成默认值。 System.out.println(empty.orElseGet(() -&gt; "Default Value")); System.out.println(name.orElseGet(() -&gt; "Default Value")); try &#123; //orElseThrow与orElse方法类似，区别在于返回值。 //orElseThrow抛出由传入的lambda表达式/方法生成异常。 empty.orElseThrow(ValueAbsentException::new); &#125; catch (Throwable ex) &#123; System.out.println(ex.getMessage()); &#125; //map方法通过传入的lambda表达式修改Optonal实例默认值。 //lambda表达式返回值会包装为Optional实例。 Optional&lt;String&gt; upperName = name.map((value) -&gt; value.toUpperCase()); System.out.println(upperName.orElse("No value found")); //flatMap与map（Funtion）非常相似，区别在于lambda表达式的返回值。 //map方法的lambda表达式返回值可以是任何类型，但是返回值会包装成Optional实例。 //但是flatMap方法的lambda返回值总是Optional类型。 upperName = name.flatMap((value) -&gt; Optional.of(value.toUpperCase())); System.out.println(upperName.orElse("No value found")); //filter方法检查Optiona值是否满足给定条件。 //如果满足返回Optional实例值，否则返回空Optional。 Optional&lt;String&gt; longName = name.filter((value) -&gt; value.length() &gt; 6); System.out.println(longName.orElse("The name is less than 6 characters")); //另一个示例，Optional值不满足给定条件。 Optional&lt;String&gt; anotherName = Optional.of("Sana"); Optional&lt;String&gt; shortName = anotherName.filter((value) -&gt; value.length() &gt; 6); System.out.println(shortName.orElse("The name is less than 6 characters")); &#125; &#125;class ValueAbsentException extends Throwable &#123; public ValueAbsentException() &#123; super(); &#125; public ValueAbsentException(String msg) &#123; super(msg); &#125; @Override public String getMessage() &#123; return "No value present in the Optional instance!"; &#125; &#125; 注：Optional之Demo来源 emmm，那Optional怎么转为List or Set集合呢?12345678910111213141516public class OptionalDemo2 &#123; public static void main(String... args)&#123; Optional&lt;String&gt; str1 = Optional.of("Test1"); Optional&lt;String&gt; str2 = Optional.of("Test2"); List&lt;String&gt; list1 = toList(str1); System.out.println(list1); List&lt;String&gt; list2 = toList(str2); System.out.println(list2); &#125;public static &lt;String&gt; List&lt;String&gt; toList(Optional&lt;String&gt; option) &#123; return option. map(Collections::singletonList). orElse(Collections.emptyList());&#125;&#125; 下一章的内容–Stream（流式操作）将会更加方便将Optional转为List or Set。下次见。 小结Java 8 APIJava SE 8: Lambda Quick Start]]></content>
      <categories>
        <category>Java 8</category>
      </categories>
      <tags>
        <tag>&lt;font size=6&gt;Java 8&lt;/font&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8新特性（一）]]></title>
    <url>%2F2017%2F10%2F29%2FJ8%2F</url>
    <content type="text"><![CDATA[小编农事训练了一周，咸鱼了一周，一直心心念念着我没有更博，这不，小编给你们带来了水析Java 8，Java 8这个专题分为4章，本章末给出学习J8（原谅我简称它）最好的学习资料—-官方文档 Java 8新特性（一）J8在2014年就发布了，J9如今也出了，更新的速度赶上坐飞机了，知乎上面有人调侃，还在研究J5、6的源码，甚至有大神调侃，用J8重构之前的项目，会出现摸不着头脑的bug，把JDK换成7居然不报错了。小编不管，就是要学习J8新特性，毕竟J8某些特性算得上Java里程碑式的了。 Lambda表达式J8通过Lambda表达式对函数式编程，函数式编程的最大特点就是能够将一个函数或者一段代码作为另外一个函数的参数。Lambda表达式可以说是J8最大的卖点了。拿来说说他的Syntax A comma-separated list of formal parameters enclosed in parentheses The arrow token, -&gt; A body, which consists of a single expression or a statement block. 是不是觉得官方文档有点晦涩，其实语法就概括如下：1(parameter，parameter) -&gt; &#123;expression body&#125; 在J8之前，匿名内部类，监听器和事件处理器的使用都显得很冗长，可读性很差，或许说的有点虚，举一个java fx的按钮监听的例子（小编的java fx菜得一笔qwq）匿名内部类：123456button.addActionListener(new ActionListener() &#123;@Overridepublic void actionPerformed(ActionEvent e) &#123;System.out.print("Helllo Lambda in actionPerformed");&#125;&#125;); 使用 Lambda 表达式后：1234button.addActionListener((ActionEvent e)-&gt; System.out.print("Helllo Lambda in actionPerformed")); 是不是觉得Lambda表达式相较于匿名内部类清爽很多，可读性更强了 废话不多说直接上一个使用多个形式参数的lambda表达式的示例：12345678910111213141516171819202122232425262728public class Calculator &#123; interface IntegerMath &#123; int operation(int a, int b); &#125; public int operateBinary(int a, int b, IntegerMath op) &#123; return op.operation(a, b); &#125; public static void main(String... args) &#123; Calculator myApp = new Calculator(); IntegerMath addition = (a, b) -&gt; a + b; IntegerMath subtraction = (a, b) -&gt; a - b; IntegerMath multiplication = (int a,int b) -&gt; a * b; IntegerMath division = (a,b) -&gt; a / b; System.out.println("40 + 2 = " + myApp.operateBinary(40, 2, addition)); System.out.println("20 - 10 = " + myApp.operateBinary(20, 10, subtraction)); System.out.println("20 * 10 = " + multiplication.operation(20, 10)); System.out.println("20 / 10 = " + division.operation(20, 10)); &#125;&#125; 运行效果如下：123440 + 2 = 4220 - 10 = 1020 * 10 = 20020 / 10 = 2 方法引用在J8中，方法也是对象能够被引用，方法引用的目的就是为了支持Lambda的缩写，让代码更加简洁可读。 方法引用分类 Kind Example Reference to a static method ContainingClass::staticMethodName Reference to an instance method of a particular object containingObject::instanceMethodName Reference to an instance method of an arbitrary object of a particular type ContainingType::methodName Reference to a constructor ClassName::new 官方文档是不是看起来特别累，其实也就是下面4种： 引用静态方法 引用特定对象的实例方法 引用特定类型的任意对象的实例方法 引用构造函数 具体语法如何，还是一样直接上代码： Reference to a static method 1Person::compareByAge Reference to a constructor 1String::new 等价于 Lambda的() -&gt; new String() reference to an instance method of a particular object 1234567891011class ComparisonProvider &#123; public int compareByName(Person a, Person b) &#123; return a.getName().compareTo(b.getName()); &#125; public int compareByAge(Person a, Person b) &#123; return a.getBirthday().compareTo(b.getBirthday()); &#125;&#125;ComparisonProvider myComparisonProvider = new ComparisonProvider();Arrays.sort(rosterAsArray, myComparisonProvider::compareByName); reference to an instance method of an arbitrary object of a particular type 123String[] stringArray = &#123; "Barbara", "James", "Mary", "John", "Patricia", "Robert", "Michael", "Linda" &#125;;Arrays.sort(stringArray, String::compareToIgnoreCase); 官方文档分别用几个小栗子来说明方法引用，小编又在其他blog中看到了一些比较完整的demo：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class MethodReference &#123; public static void main(String[] args) &#123; // 方法引用::引用构造函数 PersonFactory factory = new PersonFactory(Person::new); List&lt;Person&gt; personList = new ArrayList&lt;Person&gt;(); Person p1 = factory.getPerson(); p1.setName("Kobe"); personList.add(p1); Person p2 = factory.getPerson(); p2.setName("James"); personList.add(p2); Person p3 = factory.getPerson(); p3.setName("Paul"); personList.add(p3); Person[] persons1 = personList.toArray(new Person[personList.size()]); System.out.print("排序前: "); printArray(persons1); // 方法引用::引用静态方法 Arrays.sort(persons1, MethodReference::myCompare); //Arrays.sort(persons1, (m,n) -&gt; MethodReference.myCompare(m, n)); System.out.print("排序后: "); printArray(persons1); System.out.println(); Person[] persons2 = personList.toArray(new Person[personList.size()]); System.out.print("排序前: "); printArray(persons2); // 方法引用::用特定对象的实例方法 Arrays.sort(persons2, p1::compare); System.out.print("排序后: "); printArray(persons2); System.out.println(); Person[] persons3 = personList.toArray(new Person[personList.size()]); System.out.print("排序前: "); printArray(persons3); // 方法引用::引用特定类型的任意对象的实例方法 Arrays.sort(persons3, Person::compareTo); System.out.print("排序后: "); printArray(persons3); &#125; public static void printArray(Person[] persons) &#123; for (Person p : persons) &#123; System.out.print(p.name + " "); &#125; System.out.println(); &#125; public static int myCompare(Person p1, Person p2) &#123; return p1.getName().compareTo(p2.getName()); &#125; static class Person &#123; private String name; public Person() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int compare(Person p1, Person p2) &#123; return p1.getName().compareTo(p2.getName()); &#125; public int compareTo(Person p) &#123; return this.getName().compareTo(p.getName()); &#125; &#125; static class PersonFactory &#123; private Supplier&lt;Person&gt; supplier; public PersonFactory(Supplier&lt;Person&gt; supplier) &#123; this.supplier = supplier; &#125; public Person getPerson() &#123; return supplier.get(); &#125; &#125; public interface Supplier&lt;T&gt; &#123; /** * Gets a result. * * @return a result */ T get(); &#125;&#125; Demo出处：java8 - 方法引用(method referrance) 总结The Java™ Tutorials 下周是下半年第一次满课，J8（二）更新不知道啥时候罗，晚安qwq]]></content>
      <categories>
        <category>Java 8</category>
      </categories>
      <tags>
        <tag>&lt;font size=6&gt;Java 8&lt;/font&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实际开发过程中乱码解决]]></title>
    <url>%2F2017%2F10%2F21%2Fcoding2%2F</url>
    <content type="text"><![CDATA[Spring MVC开发过程中遇到的乱码解决Post乱码在页面编码格式中设置为pageEncoding=”UTF-8”%并且表单的form的提交方式：method=”post” 这时候在工程目录下的web.xml添加post乱码过滤器filter在web.xml中加入（代码尽量往前靠）：123456789101112&lt;filter&gt;&lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;&lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;&lt;init-param&gt;&lt;param-name&gt;encoding&lt;/param-name&gt;&lt;param-value&gt;utf-8&lt;/param-value&gt;&lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;&lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 以上可以解决post请求乱码问题 get请求中文参数乱码方法一：对参数进行重新编码1String userName = new String(request.getParamter("userName").getBytes("ISO8859-1"),"utf-8") 其中ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码 不过，小编查资料得知，tomcat8以后默认编码格式是utf-8；7之前的都是iso8859-1，不管了，自己可以去tomcat下面验证一下。 方法二：修改tomcat配置文件假如说tomcat8以后默认的编码格式是utf-8，那就是没问题的。如果不是，修改tomcat下的conf/server.xml文件，添加编码与工程编码一致找到下面代码1&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 这段代码主要是Tomcat监听HTTP请求的端口号等信息添加URIEncoding=”utf-8”后变成1&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" URIEncoding="UTF-8" /&gt; 对于存入数据库后乱码问题可以看一看数据库连接池的设置的字符集和数据库本身的编码格式，这里就不水了。 小结上面主要是小编自己开发过程遇到乱码后亲测有效的解决办法，如果说，解决不了，可以联系我，一起讨论学习qwq]]></content>
      <categories>
        <category>乱码</category>
      </categories>
      <tags>
        <tag>&lt;font size=6&gt;Java乱码&lt;/font&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java乱码]]></title>
    <url>%2F2017%2F10%2F20%2Fcoding%2F</url>
    <content type="text"><![CDATA[编程初学者，可能在刚开发的时候，总会遇到一些‘神奇’的问题，比如字符乱码。本章就是小编水析Java编码的时候啦。 编码小故事计算机最先在美国开始投入使用，他们需要用一些bit组合来表示不同的状态，他们发现一个字节有8个bit能代表256种不同的状态，大家于是乎他这称为‘Ascii’编码。后来计算机在世界范围内流行起来，1个字节早已经不能满足全世界各种语言字符编码的要求了。但是这难不倒聪明的中国人，我们改装编码方式，用2个字节重新进行编码，这就是常说的‘全角’字符。于是乎，称这种方案为‘gb2312’，之后，发展GBK到gb18030，都是汉字编码的发展历程，统称‘双字节字符集’。不难想象，各国都搞自己那一套编码方案，到头来就只有一个结果–大家一起来乱码。最后，一个ISO组织出来收拾烂摊子，重新搞一个支持全球字符的统一编码，称为‘unicode’。unicode统一规定，用16位表示所有字符，这就意味着Ascii的那些‘半角’字符也需要2个字节，导致浪费了一半的空间，这下，美国人可不乐意了，凭什么？！直到了UTF-8的出现，它最大的特点就是它是一种变长的编码方式。这就意味这Ascii还是一个字节表示，但是utf-8一个汉字一般占3个字节，这下差不多皆大欢喜了。 场景一：ISO-8859-1与UTF-8 注：ISO-8859-1编码是单字节编码，向下兼容ASCII，是ASCII的扩展。 直接上代码：12345678String string1 = "编码";System.out.println("初始化unicode字符串:"+string1);byte[] byteList1 = string1.getBytes("utf-8");String string2 = new String(byteList1,"ISO-8859-1");System.out.println("转成ISO-8859-1乱码:"+string2);byte[] byteList2 = string2.getBytes("ISO-8859-1");String string3 = new String(byteList2,"utf-8");System.out.println("字符恢复正常："+string3); 运行后在console中如下：123初始化unicode字符串:编码转成ISO-8859-1乱码:ç¼ç字符恢复正常：编码 先看一下字符：unicode -&gt; encode by utf-8 -&gt; decode by ISO-8859-1（乱码） -&gt; encode by ISO-8859-1 -&gt; decode by utf-8（正常） 场景二：GBK与UTF-8老套路直接上代码：12345678String string1 = "编码";System.out.println("初始化unicode字符串:"+string1);byte[] byteList1 = string1.getBytes("utf-8");String string2 = new String(byteList1,"gbk");System.out.println("转成gbk乱码:"+string2);byte[] byteList2 = string2.getBytes("gbk");String string3 = new String(byteList2,"utf-8");System.out.println("字符恢复正常："+string3); 在console如下：123初始化unicode字符串:编码转成gbk乱码:缂栫爜字符恢复正常：编码 先看一下字符：unicode -&gt; encode by utf-8 -&gt; decode by gbk（乱码） -&gt; encode by gbk -&gt; decode by utf-8（正常） emm,看起来似乎没什么大的问题，其实不就是不管中间编码，其实到最后转回来就ok了嘛。但是，小编居然看到一篇blog说这其实是个误区，那就来证实一下啦。 证实：修改原字符串将上面的unicode字符串修改成：编码咯ISO-8859-1：1字符恢复正常：编码咯 gbk:1字符恢复正常：编码�? 来个结论经过小编的大量测试，发现ISO-8859-1作为中间编码是安全的，而gbk作为中间编码是不安全的（偶数字符长安全，奇数不安全） why 为什么会出现这种神奇的现象？想知道答案当然是看中间码的具体字节流啦 还是一样，简单直接上代码：12345StringBuffer sb = new StringBuffer();for (byte b : byteArray) &#123;sb.append(Integer.toHexString(b &amp; 0xFF)); sb.append(" ");&#125; 注：ava.lang.Integer.toHexString()方法返回的字符串表示的无符号整数参数所表示的值以十六进制以表示。在64位计算机中数字以64位格式存储，若byte（8位）数字，高几位能有随机性，只有低8位才是有效数字，所以 &amp; 上0xFF 中间码为ISO-8859-1安全的没问题然后看一下中间码为GBK的console：字符串为偶数的时候：12utf Byte：e7 bc 96 e7 a0 81gbk Byte：e7 bc 96 e7 a0 81 字符串为奇数的时候：12utf Byte：e7 bc 96 e7 a0 81 e5 92 afgbk Byte：e7 bc 96 e7 a0 81 e5 92 3f 看到这有木有恍然大悟呀blog开头就说了，utf-8一个汉字占3个byte，ISO-8859-1是单字节编码,gbk是双字节编码所以ISO-8859-1都是这样的字节流：[e7] [bc] [96] [e7] [a0] [81] [e5] [92] [af]这个是安全的 而当GBK时，字符串为偶数时候，gbk的字节流是：[e7 bc] [96 e7] [a0 81] 当字符串是奇数时，gbk的字节流是：[e7 bc] [96 e7] [a0 81] [e5 92] af gbk的字节流多出了af无法组合，于是用一个半角Ascii字符的 “？” 代替（3f刚好就是Ascii的‘？’） 小结中间码不一定全是安全的，ISO-8859-1作为中间码是安全的，但是，utf-8或者gbk作为中间码其实都是不安全的。 附上一句：使用什么编码，就用什么解码。]]></content>
      <categories>
        <category>乱码</category>
      </categories>
      <tags>
        <tag>&lt;font size=6&gt;Java乱码&lt;/font&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统概念(一)]]></title>
    <url>%2F2017%2F10%2F16%2FDSC1%2F</url>
    <content type="text"><![CDATA[注：最近学校在教《Database System Concepts》这本书，又刚好在做这个博客，那就顺手将这个当做一个专题（其实小编的真实意图是做做笔记的qwq） 数据的完整性和约束条件一、数据完整性约束 直白点说，一个稍微大点的project，数据库表的结构一般都不简单，所以建表以后需要有关表的文档，否则，很有可能出现因当前负责这个模块的人离开而后续的开发者接触到这坨表后的一脸懵逼。表的数据有一定得取值范围和约束条件，多表之间更是有一定得参考关系。其中我们可以通过定义约束条件来保证数据的完整性和一致性。数据的完整性又包括数据完整性和参照完整性，数据完整性定义表数据的约束条件，参照完整性定义数据之间的约束条件。数据完整性由主键(PRIMARY KEY)、非空(NOT NULL)、惟一(UNIQUE)和检查(CHECK)约束条件定义，参照完整性由外键(FOREIGN KEY)约束条件定义。 二、表的5种约束 主键(PRIMARY KEY) 非空(NOT NULL) 唯一(UNIQUE) 检查(CHECK) 外键(FOREIGN KEY) 这次主要讲讲外键： 指定表的一列或多列的组合作为外键(一列的称为列级，多列的称为表级)，外键参照指定的主键或惟一键。 两个表含有主键或惟一键的称为主表，定义外键的那张表称为子表，子表参照主表的数据（这就意味着子表的数据来源于主表，子表‘抄袭’主表，子表的数据在主表中一定存在，反之则不一定） 三、外键约束的语法 外键约束的语法如下：第一种语法，如果子记录存在，则不允许删除主记录：[CONSTRAINT 约束名] FOREIGN KEY(列名 1,列名 2,…)REFERENCES 表名(列名 1,列名 2,…) 第二种语法，如果子记录存在，则删除主记录时，级联删除子记录：[CONSTRAINT 约束名] FOREIGN KEY(列名 1,列名 2,…)REFERENCES 表名(列名 1,列名 2,…)on delete cascade 第三种语法，如果子记录存在，则更新主记录时，级联更新子记录：[CONSTRAINT 约束名] FOREIGN KEY(列名 1,列名 2,…)REFERENCES 表名(列名 1,列名2,…)on update cascade （oracle 9i 不支持） 第四种语法，如果子记录存在，则删除主记录时，将子记录置成空：[CONSTRAINT 约束名] FOREIGN KEY(列名 1,列名 2,…)REFERENCES 表名(列名 1,列名 2,…)on delete set null 其中的表名为要参照的表名。 注意：CONSTRAINT 关键字用来定义约束名，如果省略，则系统自动生成以 SYS_开头的唯一约束名。约束名的作用是当发生违反约束条件的操作时，系统会显示违反的约束条件名称，这样用户就可以了解到发生错误的原因。 四、约束的应用1、可以通过下面的代码来查看表的约束条件 123select constraint_name, constraint_type, search_conditionfrom user_constraintswhere table_name='your table_name' 2、其中CONSTRAINTS_TYPE 显示的约束类型为： C：CHECK 约束。 P：PRIMARY KEY 约束。 U：UNIQUE 约束。 R：FOREIGN KEY 约束。 3、有时候在表格中插入或导出大量的数据的时候，可以暂时忽略约束，使数据最大化的流通，待操作完之后可以重新开启约束 使约束条件失效： 1ALTER TABLE 表名 DISABLE CONSTRAINT 约束名; 使约束条件生效： 1ALTER TABLE 表名 ENABLE CONSTRAINT 约束名; 注：使约束条件生效的时候必须使表中所有的元组符合约束条件，否则，会报ERROR * 五、总结本章主要是有关表的约束条件，具体请看上面（小编要睡午觉了，其实就是偷懒）]]></content>
      <categories>
        <category>数据库系统概念</category>
      </categories>
      <tags>
        <tag>&lt;font size=6&gt;MySQL&lt;/font&gt;</tag>
        <tag>&lt;font size=6&gt;Oracle&lt;/font&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello,my blog]]></title>
    <url>%2F2017%2F10%2F12%2Fhello-my-blog%2F</url>
    <content type="text"><![CDATA[前言最近在知乎上面随便浏览一些和编程相关的东西，然后发现一些非常有意思的现象，大牛们都喜欢动不动将他们的GitHub账号show出来，emmm，还有他们的博客（有博客园、GitHub pages等等的），突然萌生一种想一边学一边写的想法，虽然本人小白一个，写得也不咋地，随便写写，笔耕不辍嘛。对比完博客园后，发现基于GitHub的博客简直是一股清流，Markdown是种轻量级的标记语言，语法很少很简单，这意味这什么？它注重的是文字编辑而不是语法，然后小白就可以愉快的写博客了呀(๑•̀ㅂ•́) ✧ Hello,my blog布衣经过3天的艰苦奋斗，不食不眠，终于将博客的主题配置，各种插件搭配安装好了，emmmm，这种感觉就像是刚入门编程这个大坑，打出Hello World时的那种激动，只不过如今是Hello,my blog（叹息）小小的希望，自己能够在繁忙的时间抽身出来写写博客（虽然内容不咋地），在未来日子里面真的可以说一声Hello 起航至何方emmm讲道理，我建立这个博客更多的是想帮自己建立一个World，能够对他说一声Hello，假如说，你们在读完我的博客觉得没意思，取关的话，完全没问题的，毕竟技术牛的博客数都数不过来，况且写博更多的是记录自己，自己喜欢怎么改怎么写就怎么做嘛，又或者说，一万个假如，你们在我的博客里面看到一些未成看到或者已经快忘记的东西，它们帮你们在编程上面节省了时间，那这就是我最大的动力了，腾多点时间出来，远离代码，跑跑步，看看电影之类的，岂不是美滋滋？ 关于作者作者就是个白衣]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>&lt;font size=5 color=red&gt;First&lt;/font&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>&lt;font size=5&gt;杂文&lt;/font&gt;</tag>
      </tags>
  </entry>
</search>
