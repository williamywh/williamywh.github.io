<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 8新特性（一）]]></title>
    <url>%2F2017%2F10%2F29%2FJ8%2F</url>
    <content type="text"><![CDATA[小编农事训练了一周，咸鱼了一周，一直心心念念着我没有更博，这不，小编给你们带来了水析Java 8，Java 8这个专题分为4章，本章末给出学习J8（原谅我简称它）最好的学习资料—-官方文档 Java 8新特性（一）J8在2014年就发布了，J9如今也出了，更新的速度赶上坐飞机了，知乎上面有人调侃，还在研究J5、6的源码，甚至有大神调侃，用J8重构之前的项目，会出现摸不着头脑的bug，把JDK换成7居然不报错了。小编不管，就是要学习J8新特性，毕竟J8某些特性算得上Java里程碑式的了。 Lambda表达式J8通过Lambda表达式对函数式编程，函数式编程的最大特点就是能够将一个函数或者一段代码作为另外一个函数的参数。Lambda表达式可以说是J8最大的卖点了。拿来说说他的Syntax A comma-separated list of formal parameters enclosed in parentheses The arrow token, -&gt; A body, which consists of a single expression or a statement block. 是不是觉得官方文档有点晦涩，其实语法就概括如下：1(parameter，parameter) -&gt; &#123;expression body&#125; 在J8之前，匿名内部类，监听器和事件处理器的使用都显得很冗长，可读性很差，或许说的有点虚，举一个java fx的按钮监听的例子（小编的java fx菜得一笔qwq）匿名内部类：123456button.addActionListener(new ActionListener() &#123;@Overridepublic void actionPerformed(ActionEvent e) &#123;System.out.print("Helllo Lambda in actionPerformed");&#125;&#125;); 使用 Lambda 表达式后：1234button.addActionListener((ActionEvent e)-&gt; System.out.print("Helllo Lambda in actionPerformed")); 是不是觉得Lambda表达式相较于匿名内部类清爽很多，可读性更强了 废话不多说直接上一个使用多个形式参数的lambda表达式的示例：12345678910111213141516171819202122232425262728public class Calculator &#123; interface IntegerMath &#123; int operation(int a, int b); &#125; public int operateBinary(int a, int b, IntegerMath op) &#123; return op.operation(a, b); &#125; public static void main(String... args) &#123; Calculator myApp = new Calculator(); IntegerMath addition = (a, b) -&gt; a + b; IntegerMath subtraction = (a, b) -&gt; a - b; IntegerMath multiplication = (int a,int b) -&gt; a * b; IntegerMath division = (a,b) -&gt; a / b; System.out.println("40 + 2 = " + myApp.operateBinary(40, 2, addition)); System.out.println("20 - 10 = " + myApp.operateBinary(20, 10, subtraction)); System.out.println("20 * 10 = " + multiplication.operation(20, 10)); System.out.println("20 / 10 = " + division.operation(20, 10)); &#125;&#125; 运行效果如下：123440 + 2 = 4220 - 10 = 1020 * 10 = 20020 / 10 = 2 方法引用在J8中，方法也是对象能够被引用，方法引用的目的就是为了支持Lambda的缩写，让代码更加简洁可读。 方法引用分类 Kind Example Reference to a static method ContainingClass::staticMethodName Reference to an instance method of a particular object containingObject::instanceMethodName Reference to an instance method of an arbitrary object of a particular type ContainingType::methodName Reference to a constructor ClassName::new 官方文档是不是看起来特别累，其实也就是下面4种： 引用静态方法 引用特定对象的实例方法 引用特定类型的任意对象的实例方法 引用构造函数 具体语法如何，还是一样直接上代码： Reference to a static method 1Person::compareByAge Reference to a constructor 1String::new 等价于 Lambda的() -&gt; new String() reference to an instance method of a particular object 1234567891011class ComparisonProvider &#123; public int compareByName(Person a, Person b) &#123; return a.getName().compareTo(b.getName()); &#125; public int compareByAge(Person a, Person b) &#123; return a.getBirthday().compareTo(b.getBirthday()); &#125;&#125;ComparisonProvider myComparisonProvider = new ComparisonProvider();Arrays.sort(rosterAsArray, myComparisonProvider::compareByName); reference to an instance method of an arbitrary object of a particular type 123String[] stringArray = &#123; "Barbara", "James", "Mary", "John", "Patricia", "Robert", "Michael", "Linda" &#125;;Arrays.sort(stringArray, String::compareToIgnoreCase); 官方文档分别用几个小栗子来说明方法引用，小编又在其他blog中看到了一些比较完整的demo：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class MethodReference &#123; public static void main(String[] args) &#123; // 方法引用::引用构造函数 PersonFactory factory = new PersonFactory(Person::new); List&lt;Person&gt; personList = new ArrayList&lt;Person&gt;(); Person p1 = factory.getPerson(); p1.setName("Kobe"); personList.add(p1); Person p2 = factory.getPerson(); p2.setName("James"); personList.add(p2); Person p3 = factory.getPerson(); p3.setName("Paul"); personList.add(p3); Person[] persons1 = personList.toArray(new Person[personList.size()]); System.out.print("排序前: "); printArray(persons1); // 方法引用::引用静态方法 Arrays.sort(persons1, MethodReference::myCompare); //Arrays.sort(persons1, (m,n) -&gt; MethodReference.myCompare(m, n)); System.out.print("排序后: "); printArray(persons1); System.out.println(); Person[] persons2 = personList.toArray(new Person[personList.size()]); System.out.print("排序前: "); printArray(persons2); // 方法引用::用特定对象的实例方法 Arrays.sort(persons2, p1::compare); System.out.print("排序后: "); printArray(persons2); System.out.println(); Person[] persons3 = personList.toArray(new Person[personList.size()]); System.out.print("排序前: "); printArray(persons3); // 方法引用::引用特定类型的任意对象的实例方法 Arrays.sort(persons3, Person::compareTo); System.out.print("排序后: "); printArray(persons3); &#125; public static void printArray(Person[] persons) &#123; for (Person p : persons) &#123; System.out.print(p.name + " "); &#125; System.out.println(); &#125; public static int myCompare(Person p1, Person p2) &#123; return p1.getName().compareTo(p2.getName()); &#125; static class Person &#123; private String name; public Person() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int compare(Person p1, Person p2) &#123; return p1.getName().compareTo(p2.getName()); &#125; public int compareTo(Person p) &#123; return this.getName().compareTo(p.getName()); &#125; &#125; static class PersonFactory &#123; private Supplier&lt;Person&gt; supplier; public PersonFactory(Supplier&lt;Person&gt; supplier) &#123; this.supplier = supplier; &#125; public Person getPerson() &#123; return supplier.get(); &#125; &#125; public interface Supplier&lt;T&gt; &#123; /** * Gets a result. * * @return a result */ T get(); &#125;&#125; Demo出处：java8 - 方法引用(method referrance) 总结The Java™ Tutorials 下周是下半年第一次满课，J8（二）更新不知道啥时候罗，晚安qwq]]></content>
      <categories>
        <category>Java 8</category>
      </categories>
      <tags>
        <tag>&lt;font size=6&gt;Java 8&lt;/font&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实际开发过程中乱码解决]]></title>
    <url>%2F2017%2F10%2F21%2Fcoding2%2F</url>
    <content type="text"><![CDATA[Spring MVC开发过程中遇到的乱码解决Post乱码在页面编码格式中设置为pageEncoding=”UTF-8”%并且表单的form的提交方式：method=”post” 这时候在工程目录下的web.xml添加post乱码过滤器filter在web.xml中加入（代码尽量往前靠）：123456789101112&lt;filter&gt;&lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;&lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;&lt;init-param&gt;&lt;param-name&gt;encoding&lt;/param-name&gt;&lt;param-value&gt;utf-8&lt;/param-value&gt;&lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;&lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 以上可以解决post请求乱码问题 get请求中文参数乱码方法一：对参数进行重新编码1String userName = new String(request.getParamter("userName").getBytes("ISO8859-1"),"utf-8") 其中ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码 不过，小编查资料得知，tomcat8以后默认编码格式是utf-8；7之前的都是iso8859-1，不管了，自己可以去tomcat下面验证一下。 方法二：修改tomcat配置文件假如说tomcat8以后默认的编码格式是utf-8，那就是没问题的。如果不是，修改tomcat下的conf/server.xml文件，添加编码与工程编码一致找到下面代码1&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 这段代码主要是Tomcat监听HTTP请求的端口号等信息添加URIEncoding=”utf-8”后变成1&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" URIEncoding="UTF-8" /&gt; 对于存入数据库后乱码问题可以看一看数据库连接池的设置的字符集和数据库本身的编码格式，这里就不水了。 小结上面主要是小编自己开发过程遇到乱码后亲测有效的解决办法，如果说，解决不了，可以联系我，一起讨论学习qwq]]></content>
      <categories>
        <category>乱码</category>
      </categories>
      <tags>
        <tag>&lt;font size=6&gt;Java乱码&lt;/font&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java乱码]]></title>
    <url>%2F2017%2F10%2F20%2Fcoding%2F</url>
    <content type="text"><![CDATA[编程初学者，可能在刚开发的时候，总会遇到一些‘神奇’的问题，比如字符乱码。本章就是小编水析Java编码的时候啦。 编码小故事计算机最先在美国开始投入使用，他们需要用一些bit组合来表示不同的状态，他们发现一个字节有8个bit能代表256种不同的状态，大家于是乎他这称为‘Ascii’编码。后来计算机在世界范围内流行起来，1个字节早已经不能满足全世界各种语言字符编码的要求了。但是这难不倒聪明的中国人，我们改装编码方式，用2个字节重新进行编码，这就是常说的‘全角’字符。于是乎，称这种方案为‘gb2312’，之后，发展GBK到gb18030，都是汉字编码的发展历程，统称‘双字节字符集’。不难想象，各国都搞自己那一套编码方案，到头来就只有一个结果–大家一起来乱码。最后，一个ISO组织出来收拾烂摊子，重新搞一个支持全球字符的统一编码，称为‘unicode’。unicode统一规定，用16位表示所有字符，这就意味着Ascii的那些‘半角’字符也需要2个字节，导致浪费了一半的空间，这下，美国人可不乐意了，凭什么？！直到了UTF-8的出现，它最大的特点就是它是一种变长的编码方式。这就意味这Ascii还是一个字节表示，但是utf-8一个汉字一般占3个字节，这下差不多皆大欢喜了。 场景一：ISO-8859-1与UTF-8 注：ISO-8859-1编码是单字节编码，向下兼容ASCII，是ASCII的扩展。 直接上代码：12345678String string1 = "编码";System.out.println("初始化unicode字符串:"+string1);byte[] byteList1 = string1.getBytes("utf-8");String string2 = new String(byteList1,"ISO-8859-1");System.out.println("转成ISO-8859-1乱码:"+string2);byte[] byteList2 = string2.getBytes("ISO-8859-1");String string3 = new String(byteList2,"utf-8");System.out.println("字符恢复正常："+string3); 运行后在console中如下：123初始化unicode字符串:编码转成ISO-8859-1乱码:ç¼ç字符恢复正常：编码 先看一下字符：unicode -&gt; encode by utf-8 -&gt; decode by ISO-8859-1（乱码） -&gt; encode by ISO-8859-1 -&gt; decode by utf-8（正常） 场景二：GBK与UTF-8老套路直接上代码：12345678String string1 = "编码";System.out.println("初始化unicode字符串:"+string1);byte[] byteList1 = string1.getBytes("utf-8");String string2 = new String(byteList1,"gbk");System.out.println("转成gbk乱码:"+string2);byte[] byteList2 = string2.getBytes("gbk");String string3 = new String(byteList2,"utf-8");System.out.println("字符恢复正常："+string3); 在console如下：123初始化unicode字符串:编码转成gbk乱码:缂栫爜字符恢复正常：编码 先看一下字符：unicode -&gt; encode by utf-8 -&gt; decode by gbk（乱码） -&gt; encode by gbk -&gt; decode by utf-8（正常） emm,看起来似乎没什么大的问题，其实不就是不管中间编码，其实到最后转回来就ok了嘛。但是，小编居然看到一篇blog说这其实是个误区，那就来证实一下啦。 证实：修改原字符串将上面的unicode字符串修改成：编码咯ISO-8859-1：1字符恢复正常：编码咯 gbk:1字符恢复正常：编码�? 来个结论经过小编的大量测试，发现ISO-8859-1作为中间编码是安全的，而gbk作为中间编码是不安全的（偶数字符长安全，奇数不安全） why 为什么会出现这种神奇的现象？想知道答案当然是看中间码的具体字节流啦 还是一样，简单直接上代码：12345StringBuffer sb = new StringBuffer();for (byte b : byteArray) &#123;sb.append(Integer.toHexString(b &amp; 0xFF)); sb.append(" ");&#125; 注：ava.lang.Integer.toHexString()方法返回的字符串表示的无符号整数参数所表示的值以十六进制以表示。在64位计算机中数字以64位格式存储，若byte（8位）数字，高几位能有随机性，只有低8位才是有效数字，所以 &amp; 上0xFF 中间码为ISO-8859-1安全的没问题然后看一下中间码为GBK的console：字符串为偶数的时候：12utf Byte：e7 bc 96 e7 a0 81gbk Byte：e7 bc 96 e7 a0 81 字符串为奇数的时候：12utf Byte：e7 bc 96 e7 a0 81 e5 92 afgbk Byte：e7 bc 96 e7 a0 81 e5 92 3f 看到这有木有恍然大悟呀blog开头就说了，utf-8一个汉字占3个byte，ISO-8859-1是单字节编码,gbk是双字节编码所以ISO-8859-1都是这样的字节流：[e7] [bc] [96] [e7] [a0] [81] [e5] [92] [af]这个是安全的 而当GBK时，字符串为偶数时候，gbk的字节流是：[e7 bc] [96 e7] [a0 81] 当字符串是奇数时，gbk的字节流是：[e7 bc] [96 e7] [a0 81] [e5 92] af gbk的字节流多出了af无法组合，于是用一个半角Ascii字符的 “？” 代替（3f刚好就是Ascii的‘？’） 小结中间码不一定全是安全的，ISO-8859-1作为中间码是安全的，但是，utf-8或者gbk作为中间码其实都是不安全的。 附上一句：使用什么编码，就用什么解码。]]></content>
      <categories>
        <category>乱码</category>
      </categories>
      <tags>
        <tag>&lt;font size=6&gt;Java乱码&lt;/font&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统概念(一)]]></title>
    <url>%2F2017%2F10%2F16%2FDSC1%2F</url>
    <content type="text"><![CDATA[注：最近学校在教《Database System Concepts》这本书，又刚好在做这个博客，那就顺手将这个当做一个专题（其实小编的真实意图是做做笔记的qwq） 数据的完整性和约束条件一、数据完整性约束 直白点说，一个稍微大点的project，数据库表的结构一般都不简单，所以建表以后需要有关表的文档，否则，很有可能出现因当前负责这个模块的人离开而后续的开发者接触到这坨表后的一脸懵逼。表的数据有一定得取值范围和约束条件，多表之间更是有一定得参考关系。其中我们可以通过定义约束条件来保证数据的完整性和一致性。数据的完整性又包括数据完整性和参照完整性，数据完整性定义表数据的约束条件，参照完整性定义数据之间的约束条件。数据完整性由主键(PRIMARY KEY)、非空(NOT NULL)、惟一(UNIQUE)和检查(CHECK)约束条件定义，参照完整性由外键(FOREIGN KEY)约束条件定义。 二、表的5种约束 主键(PRIMARY KEY) 非空(NOT NULL) 唯一(UNIQUE) 检查(CHECK) 外键(FOREIGN KEY) 这次主要讲讲外键： 指定表的一列或多列的组合作为外键(一列的称为列级，多列的称为表级)，外键参照指定的主键或惟一键。 两个表含有主键或惟一键的称为主表，定义外键的那张表称为子表，子表参照主表的数据（这就意味着子表的数据来源于主表，子表‘抄袭’主表，子表的数据在主表中一定存在，反之则不一定） 三、外键约束的语法 外键约束的语法如下：第一种语法，如果子记录存在，则不允许删除主记录：[CONSTRAINT 约束名] FOREIGN KEY(列名 1,列名 2,…)REFERENCES 表名(列名 1,列名 2,…) 第二种语法，如果子记录存在，则删除主记录时，级联删除子记录：[CONSTRAINT 约束名] FOREIGN KEY(列名 1,列名 2,…)REFERENCES 表名(列名 1,列名 2,…)on delete cascade 第三种语法，如果子记录存在，则更新主记录时，级联更新子记录：[CONSTRAINT 约束名] FOREIGN KEY(列名 1,列名 2,…)REFERENCES 表名(列名 1,列名2,…)on update cascade （oracle 9i 不支持） 第四种语法，如果子记录存在，则删除主记录时，将子记录置成空：[CONSTRAINT 约束名] FOREIGN KEY(列名 1,列名 2,…)REFERENCES 表名(列名 1,列名 2,…)on delete set null 其中的表名为要参照的表名。 注意：CONSTRAINT 关键字用来定义约束名，如果省略，则系统自动生成以 SYS_开头的唯一约束名。约束名的作用是当发生违反约束条件的操作时，系统会显示违反的约束条件名称，这样用户就可以了解到发生错误的原因。 四、约束的应用1、可以通过下面的代码来查看表的约束条件 123select constraint_name, constraint_type, search_conditionfrom user_constraintswhere table_name='your table_name' 2、其中CONSTRAINTS_TYPE 显示的约束类型为： C：CHECK 约束。 P：PRIMARY KEY 约束。 U：UNIQUE 约束。 R：FOREIGN KEY 约束。 3、有时候在表格中插入或导出大量的数据的时候，可以暂时忽略约束，使数据最大化的流通，待操作完之后可以重新开启约束 使约束条件失效： 1ALTER TABLE 表名 DISABLE CONSTRAINT 约束名; 使约束条件生效： 1ALTER TABLE 表名 ENABLE CONSTRAINT 约束名; 注：使约束条件生效的时候必须使表中所有的元组符合约束条件，否则，会报ERROR * 五、总结本章主要是有关表的约束条件，具体请看上面（小编要睡午觉了，其实就是偷懒）]]></content>
      <categories>
        <category>数据库系统概念</category>
      </categories>
      <tags>
        <tag>&lt;font size=6&gt;MySQL&lt;/font&gt;</tag>
        <tag>&lt;font size=6&gt;Oracle&lt;/font&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello,my blog]]></title>
    <url>%2F2017%2F10%2F12%2Fhello-my-blog%2F</url>
    <content type="text"><![CDATA[前言最近在知乎上面随便浏览一些和编程相关的东西，然后发现一些非常有意思的现象，大牛们都喜欢动不动将他们的GitHub账号show出来，emmm，还有他们的博客（有博客园、GitHub pages等等的），突然萌生一种想一边学一边写的想法，虽然本人小白一个，写得也不咋地，随便写写，笔耕不辍嘛。对比完博客园后，发现基于GitHub的博客简直是一股清流，Markdown是种轻量级的标记语言，语法很少很简单，这意味这什么？它注重的是文字编辑而不是语法，然后小白就可以愉快的写博客了呀(๑•̀ㅂ•́) ✧ Hello,my blog布衣经过3天的艰苦奋斗，不食不眠，终于将博客的主题配置，各种插件搭配安装好了，emmmm，这种感觉就像是刚入门编程这个大坑，打出Hello World时的那种激动，只不过如今是Hello,my blog（叹息）小小的希望，自己能够在繁忙的时间抽身出来写写博客（虽然内容不咋地），在未来日子里面真的可以说一声Hello 起航至何方emmm讲道理，我建立这个博客更多的是想帮自己建立一个World，能够对他说一声Hello，假如说，你们在读完我的博客觉得没意思，取关的话，完全没问题的，毕竟技术牛的博客数都数不过来，况且写博更多的是记录自己，自己喜欢怎么改怎么写就怎么做嘛，又或者说，一万个假如，你们在我的博客里面看到一些未成看到或者已经快忘记的东西，它们帮你们在编程上面节省了时间，那这就是我最大的动力了，腾多点时间出来，远离代码，跑跑步，看看电影之类的，岂不是美滋滋？ 关于作者作者就是个白衣]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>&lt;font size=5 color=red&gt;First&lt;/font&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>&lt;font size=5&gt;杂文&lt;/font&gt;</tag>
      </tags>
  </entry>
</search>
