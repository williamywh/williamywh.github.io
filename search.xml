<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅谈Java乱码]]></title>
    <url>%2F2017%2F10%2F20%2Fcoding%2F</url>
    <content type="text"><![CDATA[编程初学者，可能在刚开发的时候，总会遇到一些‘神奇’的问题，比如字符乱码。本章就是小编水析Java编码的时候啦。 编码小故事计算机最先在美国开始投入使用，他们需要用一些bit组合来表示不同的状态，他们发现一个字节有8个bit能代表256种不同的状态，大家于是乎他这称为‘Ascii’编码。后来计算机在世界范围内流行起来，1个字节早已经不能满足全世界各种语言字符编码的要求了。但是这难不倒聪明的中国人，我们改装编码方式，用2个字节重新进行编码，这就是常说的‘全角’字符。于是乎，称这种方案为‘gb2312’，之后，发展GBK到gb18030，都是汉字编码的发展历程，统称‘双字节字符集’。不难想象，各国都搞自己那一套编码方案，到头来就只有一个结果–大家一起来乱码。最后，一个ISO组织出来收拾烂摊子，重新搞一个支持全球字符的统一编码，称为‘unicode’。unicode统一规定，用16位表示所有字符，这就意味着Ascii的那些‘半角’字符也需要2个字节，导致浪费了一半的空间，这下，美国人可不乐意了，凭什么？！直到了UTF-8的出现，它最大的特点就是它是一种变长的编码方式。这就意味这Ascii还是一个字节表示，但是utf-8一个汉字一般占3个字节，这下差不多皆大欢喜了。 场景一：ISO-8859-1与UTF-8 注：ISO-8859-1编码是单字节编码，向下兼容ASCII，是ASCII的扩展。 直接上代码：12345678String string1 = "编码";System.out.println("初始化unicode字符串:"+string1);byte[] byteList1 = string1.getBytes("utf-8");String string2 = new String(byteList1,"ISO-8859-1");System.out.println("转成ISO-8859-1乱码:"+string2);byte[] byteList2 = string2.getBytes("ISO-8859-1");String string3 = new String(byteList2,"utf-8");System.out.println("字符恢复正常："+string3); 运行后在console中如下：123初始化unicode字符串:编码转成ISO-8859-1乱码:ç¼ç字符恢复正常：编码 先看一下字符：unicode -&gt; encode by utf-8 -&gt; decode by ISO-8859-1（乱码） -&gt; encode by ISO-8859-1 -&gt; decode by utf-8（正常） 场景二：GBK与UTF-8老套路直接上代码：12345678String string1 = "编码";System.out.println("初始化unicode字符串:"+string1);byte[] byteList1 = string1.getBytes("utf-8");String string2 = new String(byteList1,"gbk");System.out.println("转成gbk乱码:"+string2);byte[] byteList2 = string2.getBytes("gbk");String string3 = new String(byteList2,"utf-8");System.out.println("字符恢复正常："+string3); 在console如下：123初始化unicode字符串:编码转成gbk乱码:缂栫爜字符恢复正常：编码 先看一下字符：unicode -&gt; encode by utf-8 -&gt; decode by gbk（乱码） -&gt; encode by gbk -&gt; decode by utf-8（正常） emm,看起来似乎没什么大的问题，其实不就是不管中间编码，其实到最后转回来就ok了嘛。但是，小编居然看到一篇blog说这其实是个误区，那就来证实一下啦。 证实：修改原字符串将上面的unicode字符串修改成：编码咯ISO-8859-1：1字符恢复正常：编码咯 gbk:1字符恢复正常：编码�? 来个结论经过小编的大量测试，发现ISO-8859-1作为中间编码是安全的，而gbk作为中间编码是不安全的（偶数字符长安全，奇数不安全） why 为什么会出现这种神奇的现象？想知道答案当然是看中间码的具体字节流啦 还是一样，简单直接上代码：12345StringBuffer sb = new StringBuffer();for (byte b : byteArray) &#123;sb.append(Integer.toHexString(b &amp; 0xFF)); sb.append(" ");&#125; 注：ava.lang.Integer.toHexString()方法返回的字符串表示的无符号整数参数所表示的值以十六进制以表示。在64位计算机中数字以64位格式存储，若byte（8位）数字，高几位能有随机性，只有低8位才是有效数字，所以 &amp; 上0xFF 中间码为ISO-8859-1安全的没问题然后看一下中间码为GBK的console：字符串为偶数的时候：12utf Byte：e7 bc 96 e7 a0 81gbk Byte：e7 bc 96 e7 a0 81 字符串为奇数的时候：12utf Byte：e7 bc 96 e7 a0 81 e5 92 afgbk Byte：e7 bc 96 e7 a0 81 e5 92 3f 看到这有木有恍然大悟呀blog开头就说了，utf-8一个汉字占3个byte，ISO-8859-1是单字节编码,gbk是双字节编码所以ISO-8859-1都是这样的字节流：[e7] [bc] [96] [e7] [a0] [81] [e5] [92] [af]这个是安全的 而当GBK时，字符串为偶数时候，gbk的字节流是：[e7 bc] [96 e7] [a0 81] 当字符串是奇数时，gbk的字节流是：[e7 bc] [96 e7] [a0 81] [e5 92] af gbk的字节流多出了af无法组合，于是用一个半角Ascii字符的 “？” 代替（3f刚好就是Ascii的‘？’） 小结中间码不一定全是安全的，ISO-8859-1作为中间码是安全的，但是，utf-8或者gbk作为中间码其实都是不安全的。 附上一句：使用什么编码，就用什么解码。]]></content>
      <categories>
        <category>乱码</category>
      </categories>
      <tags>
        <tag>&lt;font size=6&gt;Java乱码&lt;/font&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统概念(一)]]></title>
    <url>%2F2017%2F10%2F16%2FDSC1%2F</url>
    <content type="text"><![CDATA[注：最近学校在教《Database System Concepts》这本书，又刚好在做这个博客，那就顺手将这个当做一个专题（其实小编的真实意图是做做笔记的qwq） 数据的完整性和约束条件一、数据完整性约束 直白点说，一个稍微大点的project，数据库表的结构一般都不简单，所以建表以后需要有关表的文档，否则，很有可能出现因当前负责这个模块的人离开而后续的开发者接触到这坨表后的一脸懵逼。表的数据有一定得取值范围和约束条件，多表之间更是有一定得参考关系。其中我们可以通过定义约束条件来保证数据的完整性和一致性。数据的完整性又包括数据完整性和参照完整性，数据完整性定义表数据的约束条件，参照完整性定义数据之间的约束条件。数据完整性由主键(PRIMARY KEY)、非空(NOT NULL)、惟一(UNIQUE)和检查(CHECK)约束条件定义，参照完整性由外键(FOREIGN KEY)约束条件定义。 二、表的5种约束 主键(PRIMARY KEY) 非空(NOT NULL) 唯一(UNIQUE) 检查(CHECK) 外键(FOREIGN KEY) 这次主要讲讲外键： 指定表的一列或多列的组合作为外键(一列的称为列级，多列的称为表级)，外键参照指定的主键或惟一键。 两个表含有主键或惟一键的称为主表，定义外键的那张表称为子表，子表参照主表的数据（这就意味着子表的数据来源于主表，子表‘抄袭’主表，子表的数据在主表中一定存在，反之则不一定） 三、外键约束的语法 外键约束的语法如下：第一种语法，如果子记录存在，则不允许删除主记录：[CONSTRAINT 约束名] FOREIGN KEY(列名 1,列名 2,…)REFERENCES 表名(列名 1,列名 2,…) 第二种语法，如果子记录存在，则删除主记录时，级联删除子记录：[CONSTRAINT 约束名] FOREIGN KEY(列名 1,列名 2,…)REFERENCES 表名(列名 1,列名 2,…)on delete cascade 第三种语法，如果子记录存在，则更新主记录时，级联更新子记录：[CONSTRAINT 约束名] FOREIGN KEY(列名 1,列名 2,…)REFERENCES 表名(列名 1,列名2,…)on update cascade （oracle 9i 不支持） 第四种语法，如果子记录存在，则删除主记录时，将子记录置成空：[CONSTRAINT 约束名] FOREIGN KEY(列名 1,列名 2,…)REFERENCES 表名(列名 1,列名 2,…)on delete set null 其中的表名为要参照的表名。 注意：CONSTRAINT 关键字用来定义约束名，如果省略，则系统自动生成以 SYS_开头的唯一约束名。约束名的作用是当发生违反约束条件的操作时，系统会显示违反的约束条件名称，这样用户就可以了解到发生错误的原因。 四、约束的应用1、可以通过下面的代码来查看表的约束条件 123select constraint_name, constraint_type, search_conditionfrom user_constraintswhere table_name='your table_name' 2、其中CONSTRAINTS_TYPE 显示的约束类型为： C：CHECK 约束。 P：PRIMARY KEY 约束。 U：UNIQUE 约束。 R：FOREIGN KEY 约束。 3、有时候在表格中插入或导出大量的数据的时候，可以暂时忽略约束，使数据最大化的流通，待操作完之后可以重新开启约束 使约束条件失效： 1ALTER TABLE 表名 DISABLE CONSTRAINT 约束名; 使约束条件生效： 1ALTER TABLE 表名 ENABLE CONSTRAINT 约束名; 注：使约束条件生效的时候必须使表中所有的元组符合约束条件，否则，会报ERROR * 五、总结本章主要是有关表的约束条件，具体请看上面（小编要睡午觉了，其实就是偷懒）]]></content>
      <categories>
        <category>数据库系统概念</category>
      </categories>
      <tags>
        <tag>&lt;font size=6&gt;MySQL&lt;/font&gt;</tag>
        <tag>&lt;font size=6&gt;Oracle&lt;/font&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello,my blog]]></title>
    <url>%2F2017%2F10%2F12%2Fhello-my-blog%2F</url>
    <content type="text"><![CDATA[前言最近在知乎上面随便浏览一些和编程相关的东西，然后发现一些非常有意思的现象，大牛们都喜欢动不动将他们的GitHub账号show出来，emmm，还有他们的博客（有博客园、GitHub pages等等的），突然萌生一种想一边学一边写的想法，虽然本人小白一个，写得也不咋地，随便写写，笔耕不辍嘛。对比完博客园后，发现基于GitHub的博客简直是一股清流，Markdown是种轻量级的标记语言，语法很少很简单，这意味这什么？它注重的是文字编辑而不是语法，然后小白就可以愉快的写博客了呀(๑•̀ㅂ•́) ✧ Hello,my blog布衣经过3天的艰苦奋斗，不食不眠，终于将博客的主题配置，各种插件搭配安装好了，emmmm，这种感觉就像是刚入门编程这个大坑，打出Hello World时的那种激动，只不过如今是Hello,my blog（叹息）小小的希望，自己能够在繁忙的时间抽身出来写写博客（虽然内容不咋地），在未来日子里面真的可以说一声Hello 起航至何方emmm讲道理，我建立这个博客更多的是想帮自己建立一个World，能够对他说一声Hello，假如说，你们在读完我的博客觉得没意思，取关的话，完全没问题的，毕竟技术牛的博客数都数不过来，况且写博更多的是记录自己，自己喜欢怎么改怎么写就怎么做嘛，又或者说，一万个假如，你们在我的博客里面看到一些未成看到或者已经快忘记的东西，它们帮你们在编程上面节省了时间，那这就是我最大的动力了，腾多点时间出来，远离代码，跑跑步，看看电影之类的，岂不是美滋滋？ 关于作者作者就是个白衣]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>&lt;font size=5 color=red&gt;First&lt;/font&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>&lt;font size=5&gt;杂文&lt;/font&gt;</tag>
      </tags>
  </entry>
</search>
